# Prompt para Claude Code: Extraer Pares Nombre-CÃ©dula con Post-procesamiento + Proximidad Espacial

## ðŸŽ¯ OBJETIVO

Necesito extraer pares nombre-cÃ©dula de formularios con el siguiente flujo:

1. **Extraer TODO el texto con coordenadas espaciales (x, y)**
2. **Post-procesamiento de nombres** (filtrar y limpiar)
3. **Post-procesamiento de cÃ©dulas** (ya existe, mantenerlo)
4. **Emparejar por proximidad espacial** (NO por Ã­ndice)

### Â¿Por quÃ© NO emparejar por Ã­ndice?

**Problema:**
```
Google extrae:  13 cÃ©dulas
Azure extrae:   15 cÃ©dulas

Si emparejo por Ã­ndice:
  nombres[0] â†” cedulas[0]  â† Puede ser incorrecto
  nombres[1] â†” cedulas[1]  â† Puede ser de otra persona
```

**SoluciÃ³n con proximidad espacial:**
```
Para cada cÃ©dula en posiciÃ³n (x=320, y=105):
  Buscar el nombre MÃS CERCANO espacialmente
  â†’ Emparejar correctamente sin importar el orden
```

---

## ðŸ—ï¸ ARQUITECTURA DE LA SOLUCIÃ“N

### Flujo Completo:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. EXTRACCIÃ“N CON COORDENADAS                               â”‚
â”‚    OCR.extract_text_with_positions(image)                   â”‚
â”‚    â†’ [                                                       â”‚
â”‚        {text: "Juan Lopez", x: 100, y: 100, w: 200, h: 30}, â”‚
â”‚        {text: "1013112859", x: 320, y: 105, w: 150, h: 25}  â”‚
â”‚      ]                                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2. POST-PROCESAMIENTO                                       â”‚
â”‚    nombres = filter_and_clean_nombres(blocks)               â”‚
â”‚    â†’ [{text: "Juan Lopez", x: 100, y: 100, ...}]           â”‚
â”‚                                                              â”‚
â”‚    cedulas = filter_and_clean_cedulas(blocks)               â”‚
â”‚    â†’ [{text: "1013112859", x: 320, y: 105, ...}]           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 3. EMPAREJAMIENTO POR PROXIMIDAD                            â”‚
â”‚    Para cada cÃ©dula:                                        â”‚
â”‚      - Calcular distancia a todos los nombres               â”‚
â”‚      - Elegir el NOMBRE MÃS CERCANO                         â”‚
â”‚      - Emparejar: nombre â†” cÃ©dula                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ðŸ“‹ TAREAS DE IMPLEMENTACIÃ“N

### TAREA 1: Actualizar GoogleVisionAdapter

**Archivo:** `src/infrastructure/ocr/google_vision_adapter.py`

#### 1.1 Agregar mÃ©todo auxiliar: `_extract_text_blocks_with_positions()`

**Ya estÃ¡ en el prompt anterior, MANTENERLO.**

Este mÃ©todo extrae bloques de texto con coordenadas (x, y, width, height).

#### 1.2 Agregar funciones de post-procesamiento

```python
def _filter_nombres(self, blocks: List[Dict]) -> List[Dict]:
    """
    Filtra bloques que son nombres.
    
    Post-procesamiento aplicado:
    1. Identificar si es nombre (letras, > 10 chars, >= 2 palabras)
    2. Limpiar texto (capitalizar, normalizar)
    3. Mantener coordenadas originales
    
    Args:
        blocks: Lista de bloques con {text, x, y, width, height, confidence}
        
    Returns:
        Lista de bloques que son nombres, post-procesados
    """
    nombres = []
    nombre_buffer = []
    
    # Ordenar bloques por posiciÃ³n (topâ†’bottom, leftâ†’right)
    sorted_blocks = sorted(blocks, key=lambda b: (b['y'], b['x']))
    
    for block in sorted_blocks:
        text = block['text']
        
        # Â¿Es parte de un nombre?
        if self._is_nombre_pattern(text):
            nombre_buffer.append(block)
        else:
            # No es nombre, guardar buffer si existe
            if nombre_buffer:
                merged = self._merge_nombre_blocks(nombre_buffer)
                if merged:
                    nombres.append(merged)
                nombre_buffer = []
    
    # Guardar Ãºltimo buffer
    if nombre_buffer:
        merged = self._merge_nombre_blocks(nombre_buffer)
        if merged:
            nombres.append(merged)
    
    return nombres

def _filter_cedulas(self, blocks: List[Dict]) -> List[Dict]:
    """
    Filtra bloques que son cÃ©dulas.
    
    Post-procesamiento aplicado:
    1. Identificar si es cÃ©dula (nÃºmeros, 7-10 dÃ­gitos)
    2. Limpiar (remover puntos, espacios)
    3. Mantener coordenadas originales
    
    Args:
        blocks: Lista de bloques con texto y coordenadas
        
    Returns:
        Lista de bloques que son cÃ©dulas, post-procesadas
    """
    cedulas = []
    
    for block in blocks:
        text = block['text']
        
        # Remover todo excepto dÃ­gitos
        cleaned = re.sub(r'[^\d]', '', text)
        
        # Validar longitud (cÃ©dulas colombianas: 7-10 dÃ­gitos)
        if 7 <= len(cleaned) <= 10:
            cedulas.append({
                'text': cleaned,  # Texto limpio
                'x': block['x'],
                'y': block['y'],
                'width': block['width'],
                'height': block['height'],
                'confidence': block['confidence']
            })
    
    return cedulas

def _is_nombre_pattern(self, text: str) -> bool:
    """
    Determina si un texto parece ser parte de un nombre.
    
    Criterios:
    - Principalmente letras (> 70%)
    - No es solo nÃºmeros
    - Puede tener espacios, acentos, Ã±
    """
    if not text or len(text) < 2:
        return False
    
    # Contar letras
    letter_count = sum(1 for c in text if c.isalpha() or c.isspace())
    letter_ratio = letter_count / len(text) if text else 0
    
    # Debe ser principalmente letras
    if letter_ratio < 0.7:
        return False
    
    # No debe ser solo nÃºmeros
    if text.replace(" ", "").isdigit():
        return False
    
    return True

def _merge_nombre_blocks(self, blocks: List[Dict]) -> Optional[Dict]:
    """
    Combina mÃºltiples bloques que forman un nombre completo.
    
    Ejemplo:
      Block 1: "Juan Sebastian" (x=100, y=100)
      Block 2: "Lopez Hernandez" (x=100, y=130)
      â†’ Merged: "Juan Sebastian Lopez Hernandez" (x=100, y=100, height=60)
    
    Args:
        blocks: Lista de bloques consecutivos que forman un nombre
        
    Returns:
        Bloque merged o None si no es vÃ¡lido
    """
    if not blocks:
        return None
    
    # Concatenar textos
    full_text = ' '.join(b['text'] for b in blocks)
    full_text = ' '.join(full_text.split())  # Normalizar espacios
    
    # Validar que es un nombre completo vÃ¡lido
    if not self._is_valid_nombre(full_text):
        return None
    
    # Formatear (Title Case)
    formatted_text = self._format_nombre(full_text)
    
    # Calcular bounding box combinado
    min_x = min(b['x'] for b in blocks)
    min_y = min(b['y'] for b in blocks)
    max_x = max(b['x'] + b['width'] for b in blocks)
    max_y = max(b['y'] + b['height'] for b in blocks)
    
    # Confianza promedio
    avg_confidence = sum(b['confidence'] for b in blocks) / len(blocks)
    
    return {
        'text': formatted_text,
        'x': min_x,
        'y': min_y,
        'width': max_x - min_x,
        'height': max_y - min_y,
        'confidence': avg_confidence
    }

def _is_valid_nombre(self, text: str) -> bool:
    """
    Verifica si es un nombre completo vÃ¡lido.
    
    Criterios:
    - Longitud >= 10 caracteres
    - Al menos 2 palabras (nombre + apellido)
    - Cada palabra >= 2 caracteres
    """
    text = text.strip()
    
    if len(text) < 10:
        return False
    
    words = text.split()
    if len(words) < 2:
        return False
    
    if any(len(word) < 2 for word in words):
        return False
    
    return True

def _format_nombre(self, text: str) -> str:
    """
    Formatea un nombre con Title Case.
    
    Respeta:
    - Nombres compuestos: "Juan Sebastian"
    - ArtÃ­culos: "de", "del", "de la"
    """
    words = text.split()
    formatted = []
    
    lowercase_articles = {'de', 'del', 'de la', 'y', 'e', 'la', 'las', 'los'}
    
    for i, word in enumerate(words):
        # Primera palabra siempre mayÃºscula
        if i == 0:
            formatted.append(word.capitalize())
        # ArtÃ­culos en minÃºscula (excepto al inicio)
        elif word.lower() in lowercase_articles:
            formatted.append(word.lower())
        # Resto con mayÃºscula inicial
        else:
            formatted.append(word.capitalize())
    
    return ' '.join(formatted)

def _pair_by_proximity(self, nombres: List[Dict], cedulas: List[Dict]) -> List[Dict]:
    """
    Empareja cada cÃ©dula con el nombre MÃS CERCANO espacialmente.
    
    Estrategia:
    1. Para cada cÃ©dula, calcular distancia a todos los nombres
    2. Elegir el nombre con menor distancia
    3. Priorizar proximidad VERTICAL (mismo renglÃ³n) con factor 2x
    4. Marcar nombres como usados para evitar duplicados
    
    Args:
        nombres: Lista de bloques de nombres con coordenadas
        cedulas: Lista de bloques de cÃ©dulas con coordenadas
        
    Returns:
        Lista de pares nombre-cÃ©dula
    """
    import math
    
    pares = []
    used_nombres = set()
    
    # Ordenar cÃ©dulas por posiciÃ³n vertical (top â†’ bottom)
    cedulas_sorted = sorted(cedulas, key=lambda c: c['y'])
    
    for cedula in cedulas_sorted:
        # Centro de la cÃ©dula
        cedula_cx = cedula['x'] + cedula['width'] / 2
        cedula_cy = cedula['y'] + cedula['height'] / 2
        
        best_nombre = None
        best_distance = float('inf')
        
        for nombre in nombres:
            # Skip si ya fue usado
            if nombre['text'] in used_nombres:
                continue
            
            # Centro del nombre
            nombre_cx = nombre['x'] + nombre['width'] / 2
            nombre_cy = nombre['y'] + nombre['height'] / 2
            
            # Calcular distancia
            # IMPORTANTE: Dar mÃ¡s peso a la distancia vertical (factor 2x)
            # porque en formularios, nombre y cÃ©dula estÃ¡n en el mismo renglÃ³n
            dx = cedula_cx - nombre_cx
            dy = (cedula_cy - nombre_cy) * 2  # Peso 2x en Y
            
            distance = math.sqrt(dx**2 + dy**2)
            
            # Penalizar si el nombre estÃ¡ MUY ABAJO de la cÃ©dula
            # (normalmente el nombre va antes/arriba de la cÃ©dula)
            if nombre_cy > cedula_cy + 50:  # Nombre 50px+ abajo
                distance *= 2  # Penalizar 2x
            
            # Penalizar si estÃ¡n MUY LEJOS horizontalmente
            # (mismo renglÃ³n implica distancia horizontal razonable)
            if abs(dx) > 500:  # MÃ¡s de 500px de separaciÃ³n horizontal
                distance *= 1.5  # Penalizar 1.5x
            
            if distance < best_distance:
                best_distance = distance
                best_nombre = nombre
        
        # Empareja si encontrÃ³ nombre cercano (< 300 pixels)
        if best_nombre and best_distance < 300:
            pares.append({
                'nombre': best_nombre['text'],
                'cedula': cedula['text'],
                'confidence_nombre': best_nombre['confidence'],
                'confidence_cedula': cedula['confidence'],
                'distance_pixels': int(best_distance),
                'nombre_coords': {
                    'x': best_nombre['x'],
                    'y': best_nombre['y']
                },
                'cedula_coords': {
                    'x': cedula['x'],
                    'y': cedula['y']
                }
            })
            
            used_nombres.add(best_nombre['text'])
            
            self.logger.debug(
                f"âœ“ Emparejado: '{best_nombre['text']}' â†” '{cedula['text']}' "
                f"(distancia: {best_distance:.0f}px)"
            )
        else:
            self.logger.warning(
                f"âš  CÃ©dula '{cedula['text']}' sin nombre cercano "
                f"(distancia mÃ­nima: {best_distance:.0f}px)"
            )
    
    return pares
```

#### 1.3 Implementar mÃ©todo principal

```python
def extract_name_cedula_pairs(self, image: Image.Image) -> List[Dict[str, str]]:
    """
    Extrae pares nombre-cÃ©dula usando post-procesamiento + proximidad espacial.
    
    Flujo:
    1. Extraer TODO el texto con coordenadas
    2. Post-procesamiento: filtrar nombres
    3. Post-procesamiento: filtrar cÃ©dulas
    4. Emparejar por proximidad espacial
    
    Returns:
        Lista de pares nombre-cÃ©dula correctamente emparejados
    """
    self.logger.info("\n" + "="*80)
    self.logger.info("GOOGLE VISION: ExtracciÃ³n de pares nombre-cÃ©dula")
    self.logger.info("="*80)
    
    # 1. Preprocesar imagen
    processed_image = self.preprocessor.preprocess(image)
    
    # 2. Extraer TODO el texto con coordenadas
    self.logger.info("[1/4] Extrayendo texto con coordenadas...")
    content = self._pil_to_bytes(processed_image)
    vision_image = vision.Image(content=content)
    
    response = self.client.document_text_detection(image=vision_image)
    self.last_raw_response = response
    
    if response.error.message:
        raise Exception(f"Google Vision error: {response.error.message}")
    
    # Extraer bloques con posiciones
    all_blocks = self._extract_text_blocks_with_positions(response)
    self.logger.info(f"  âœ“ ExtraÃ­dos {len(all_blocks)} bloques de texto")
    
    # 3. Post-procesamiento: filtrar nombres
    self.logger.info("[2/4] Post-procesando nombres...")
    nombres = self._filter_nombres(all_blocks)
    self.logger.info(f"  âœ“ Detectados {len(nombres)} nombres")
    for n in nombres:
        self.logger.debug(f"    - {n['text']} (conf: {n['confidence']:.2%})")
    
    # 4. Post-procesamiento: filtrar cÃ©dulas
    self.logger.info("[3/4] Post-procesando cÃ©dulas...")
    cedulas = self._filter_cedulas(all_blocks)
    self.logger.info(f"  âœ“ Detectadas {len(cedulas)} cÃ©dulas")
    for c in cedulas:
        self.logger.debug(f"    - {c['text']} (conf: {c['confidence']:.2%})")
    
    # 5. Emparejar por proximidad espacial
    self.logger.info("[4/4] Emparejando por proximidad espacial...")
    pares = self._pair_by_proximity(nombres, cedulas)
    self.logger.info(f"  âœ“ Emparejados {len(pares)} pares")
    
    self.logger.info("="*80 + "\n")
    
    return pares
```

---

### TAREA 2: Implementar Igual en AzureVisionAdapter

**Archivo:** `src/infrastructure/ocr/azure_vision_adapter.py`

**Implementar los mismos mÃ©todos:**
- `_extract_text_blocks_with_positions()` (adaptado a Azure Read API)
- `_filter_nombres()`
- `_filter_cedulas()`
- `_pair_by_proximity()`
- `extract_name_cedula_pairs()`

**Diferencia clave:**
Azure Read API retorna estructura diferente:
```python
result.analyze_result.read_results[].lines[]
# Cada line tiene: text, bounding_box, words[]
```

---

### TAREA 3: Implementar Ensemble

**Archivo:** `src/infrastructure/ocr/digit_level_ensemble_ocr.py`

```python
def extract_name_cedula_pairs(self, image: Image.Image) -> List[Dict[str, str]]:
    """
    Extrae pares nombre-cÃ©dula usando ensemble de Google + Azure.
    
    Estrategia:
    1. Ambos OCR extraen sus pares independientemente
    2. Emparejar pares similares entre Google y Azure
    3. Para cada par:
       - Nombre: usar el de mayor confianza
       - CÃ©dula: usar ensemble por dÃ­gito (ya implementado)
    """
    
    self.logger.info("\n" + "="*80)
    self.logger.info("DUAL ENSEMBLE: ExtracciÃ³n de pares nombre-cÃ©dula")
    self.logger.info("="*80)
    
    # Ejecutar ambos OCR
    google_pairs = self.primary_ocr.extract_name_cedula_pairs(image)
    azure_pairs = self.secondary_ocr.extract_name_cedula_pairs(image)
    
    self.logger.info(f"Google: {len(google_pairs)} pares")
    self.logger.info(f"Azure:  {len(azure_pairs)} pares")
    
    # Emparejar pares similares
    matched = self._match_pairs(google_pairs, azure_pairs)
    self.logger.info(f"Emparejados: {len(matched)} pares\n")
    
    # Combinar informaciÃ³n
    final_pairs = []
    
    for idx, (g_pair, a_pair) in enumerate(matched, 1):
        self.logger.info(f"[Par {idx}/{len(matched)}]")
        self.logger.info(f"  Google: {g_pair['nombre']} â†’ {g_pair['cedula']}")
        self.logger.info(f"  Azure:  {a_pair['nombre']} â†’ {a_pair['cedula']}")
        
        # NOMBRE: usar el de mayor confianza
        if g_pair['confidence_nombre'] >= a_pair['confidence_nombre']:
            final_nombre = g_pair['nombre']
            conf_nombre = g_pair['confidence_nombre']
            nombre_source = 'Google'
        else:
            final_nombre = a_pair['nombre']
            conf_nombre = a_pair['confidence_nombre']
            nombre_source = 'Azure'
        
        # CÃ‰DULA: usar ensemble por dÃ­gito si difieren
        if g_pair['cedula'] == a_pair['cedula']:
            final_cedula = g_pair['cedula']
            conf_cedula = (g_pair['confidence_cedula'] + a_pair['confidence_cedula']) / 2
            cedula_source = 'Ambos'
        else:
            # Usar ensemble por dÃ­gito (tu implementaciÃ³n existente)
            combined = self._combine_cedulas_by_digit(
                g_pair['cedula'],
                a_pair['cedula'],
                g_pair['confidence_cedula'],
                a_pair['confidence_cedula']
            )
            
            final_cedula = combined['cedula']
            conf_cedula = combined['confidence']
            cedula_source = 'Ensemble'
        
        self.logger.info(f"  â†’ FINAL: {final_nombre} â†’ {final_cedula}")
        self.logger.info(f"    Nombre de {nombre_source} (conf: {conf_nombre:.2%})")
        self.logger.info(f"    CÃ©dula de {cedula_source} (conf: {conf_cedula:.2%})\n")
        
        final_pairs.append({
            'nombre': final_nombre,
            'cedula': final_cedula,
            'confidence_nombre': conf_nombre,
            'confidence_cedula': conf_cedula
        })
    
    self.logger.info("="*80 + "\n")
    
    return final_pairs

def _match_pairs(self, google_pairs: List[Dict], azure_pairs: List[Dict]) -> List[Tuple]:
    """
    Empareja pares similares entre Google y Azure.
    
    Usa similitud de cÃ©dulas (mÃ¡s confiable que nombres).
    """
    from difflib import SequenceMatcher
    
    matched = []
    used_azure = set()
    
    for g_pair in google_pairs:
        best_match = None
        best_similarity = 0.0
        
        for a_idx, a_pair in enumerate(azure_pairs):
            if a_idx in used_azure:
                continue
            
            # Similitud de cÃ©dulas (peso 80%)
            cedula_sim = SequenceMatcher(
                None,
                g_pair['cedula'],
                a_pair['cedula']
            ).ratio()
            
            # Similitud de nombres (peso 20%)
            nombre_sim = SequenceMatcher(
                None,
                g_pair['nombre'].lower(),
                a_pair['nombre'].lower()
            ).ratio()
            
            similarity = (cedula_sim * 0.8) + (nombre_sim * 0.2)
            
            if similarity > best_similarity:
                best_similarity = similarity
                best_match = (a_pair, a_idx)
        
        if best_match and best_similarity >= 0.6:
            matched.append((g_pair, best_match[0]))
            used_azure.add(best_match[1])
    
    return matched
```

---

## âœ… CRITERIOS DE Ã‰XITO

1. âœ… **Extrae texto con coordenadas espaciales**
2. âœ… **Post-procesamiento efectivo** de nombres y cÃ©dulas
3. âœ… **Emparejamiento correcto** por proximidad (NO por Ã­ndice)
4. âœ… **Funciona aunque Google encuentre 13 y Azure 15**
5. âœ… **Logging claro** de cada paso
6. âœ… **No se pierden pares** por desincronizaciÃ³n de Ã­ndices

---

## ðŸ“Š EJEMPLO DE OUTPUT

```
================================================================================
DUAL ENSEMBLE: ExtracciÃ³n de pares nombre-cÃ©dula
================================================================================

GOOGLE VISION: ExtracciÃ³n de pares nombre-cÃ©dula
================================================================================
[1/4] Extrayendo texto con coordenadas...
  âœ“ ExtraÃ­dos 47 bloques de texto
[2/4] Post-procesando nombres...
  âœ“ Detectados 3 nombres
    - Juan Sebastian Lopez Hernandez (conf: 96%)
    - Maria Garcia Perez (conf: 94%)
    - Carlos Andres Martinez (conf: 95%)
[3/4] Post-procesando cÃ©dulas...
  âœ“ Detectadas 3 cÃ©dulas
    - 1013112859 (conf: 97%)
    - 51723468 (conf: 95%)
    - 1036221525 (conf: 96%)
[4/4] Emparejando por proximidad espacial...
  âœ“ Emparejado: 'Juan Sebastian Lopez Hernandez' â†” '1013112859' (distancia: 45px)
  âœ“ Emparejado: 'Maria Garcia Perez' â†” '51723468' (distancia: 52px)
  âœ“ Emparejado: 'Carlos Andres Martinez' â†” '1036221525' (distancia: 48px)
  âœ“ Emparejados 3 pares
================================================================================

[Similar output para Azure...]

Google: 3 pares
Azure:  3 pares
Emparejados: 3 pares

[Par 1/3]
  Google: Juan Sebastian Lopez Hernandez â†’ 1013112859
  Azure:  Juan Sebastian Lopez Hernandez â†’ 1013112859
  â†’ FINAL: Juan Sebastian Lopez Hernandez â†’ 1013112859
    Nombre de Google (conf: 96%)
    CÃ©dula de Ambos (conf: 97%)

[Similar para pares 2 y 3...]
================================================================================
```

---

**Claude Code: Implementa extracciÃ³n de pares nombre-cÃ©dula usando post-procesamiento + proximidad espacial. NO usar Ã­ndices para emparejar.** ðŸš€