# Prompt para Claude Code: Implementaci√≥n de Ensemble OCR con Confianza por D√≠gito

## üéØ OBJETIVO DEL PROYECTO

Estoy construyendo un sistema de automatizaci√≥n para recolecci√≥n de firmas de candidatos presidenciales en Colombia. El sistema extrae **c√©dulas manuscritas** de formularios escaneados.

### Problema Actual

Actualmente tengo implementados dos OCR:
- ‚úÖ **Google Cloud Vision API** (95-98% precisi√≥n)
- ‚úÖ **Azure Computer Vision Read API v4.0** (implementado recientemente)

**PROBLEMA:** Ambos OCR a veces cometen errores en d√≠gitos espec√≠ficos:
- Google puede confundir un **1 con 7** en cierta posici√≥n
- Azure puede ser m√°s preciso en esa posici√≥n pero fallar en otra
- Actualmente elijo **la c√©dula completa** con mayor confianza total

### La Soluci√≥n: Ensemble a Nivel de D√≠gito

En lugar de elegir una c√©dula completa, vamos a hacer algo **mucho m√°s inteligente**:

**COMPARAR D√çGITO POR D√çGITO y elegir el que tenga mayor confianza individual**

#### Ejemplo Visual:

**M√©todo Actual (Malo):**
```
Google:  "1036221525" confianza total: 95% ‚Üí ELEGIR ESTO
Azure:   "7036221525" confianza total: 92% ‚Üí DESCARTAR
```
Problema: Si Azure tiene raz√≥n en el primer d√≠gito, lo perdemos.

**M√©todo Nuevo (Inteligente):**
```
Posici√≥n 0:  Google "1" (98%) vs Azure "7" (88%) ‚Üí Elegir "1" ‚úÖ
Posici√≥n 1:  Google "0" (95%) vs Azure "0" (96%) ‚Üí Elegir "0" ‚úÖ  
Posici√≥n 2:  Google "3" (92%) vs Azure "3" (97%) ‚Üí Elegir "3" ‚úÖ
Posici√≥n 3:  Google "6" (94%) vs Azure "6" (95%) ‚Üí Elegir "6" ‚úÖ
Posici√≥n 4:  Google "2" (89%) vs Azure "2" (94%) ‚Üí Elegir "2" ‚úÖ
Posici√≥n 5:  Google "2" (93%) vs Azure "2" (91%) ‚Üí Elegir "2" ‚úÖ
Posici√≥n 6:  Google "1" (96%) vs Azure "7" (85%) ‚Üí Elegir "1" ‚úÖ
Posici√≥n 7:  Google "5" (90%) vs Azure "5" (93%) ‚Üí Elegir "5" ‚úÖ
Posici√≥n 8:  Google "2" (88%) vs Azure "2" (92%) ‚Üí Elegir "2" ‚úÖ
Posici√≥n 9:  Google "5" (95%) vs Azure "5" (94%) ‚Üí Elegir "5" ‚úÖ

RESULTADO FINAL: "1036221525"
Confianza promedio: 96.3%
Fuentes: Google: 6 d√≠gitos, Azure: 4 d√≠gitos
```

**VENTAJAS:**
- ‚úÖ Aprovechamos lo mejor de cada OCR
- ‚úÖ Mayor precisi√≥n global (esperamos 98-99%+)
- ‚úÖ Reducci√≥n de errores cr√≠ticos (1 vs 7) a casi 0%
- ‚úÖ Confianza m√°s alta por d√≠gito
- ‚úÖ Validaci√≥n cruzada autom√°tica

---

## üìê ARQUITECTURA ACTUAL

```
src/
‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îî‚îÄ‚îÄ ports/
‚îÇ       ‚îî‚îÄ‚îÄ ocr_port.py                    # Interface base
‚îú‚îÄ‚îÄ infrastructure/
‚îÇ   ‚îú‚îÄ‚îÄ ocr/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ google_vision_adapter.py       # ‚úÖ Implementado
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ azure_vision_adapter.py        # ‚úÖ Implementado
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ensemble_ocr.py                # ‚ö†Ô∏è Necesita mejoras
‚îÇ   ‚îî‚îÄ‚îÄ image/
‚îÇ       ‚îú‚îÄ‚îÄ enhancer.py                    # Pipeline preprocesamiento
‚îÇ       ‚îú‚îÄ‚îÄ preprocessor.py
‚îÇ       ‚îî‚îÄ‚îÄ quality_metrics.py
‚îú‚îÄ‚îÄ application/
‚îÇ   ‚îî‚îÄ‚îÄ use_cases/
‚îÇ       ‚îî‚îÄ‚îÄ extract_cedulas.py             # Caso de uso principal
config/
‚îî‚îÄ‚îÄ settings.yaml                          # Configuraci√≥n
```

---

## üõ†Ô∏è TAREAS DE IMPLEMENTACI√ìN

### TAREA 1: Modificar Google Vision Adapter

**Archivo:** `src/infrastructure/ocr/google_vision_adapter.py`

**Objetivo:** Exponer la confianza individual de cada car√°cter detectado.

**Cambios necesarios:**

1. **Agregar propiedad para guardar respuesta cruda:**
```python
class GoogleVisionAdapter(OCRPort):
    def __init__(self, config: ConfigPort):
        # ... c√≥digo existente ...
        self.last_raw_response = None  # NUEVO
```

2. **Guardar respuesta completa en extract_numbers():**
```python
def extract_numbers(self, image: Image.Image) -> List[str]:
    # ... c√≥digo existente ...
    response = client.text_detection(image=vision_image)
    self.last_raw_response = response  # GUARDAR RESPUESTA
    # ... resto del c√≥digo ...
```

3. **Agregar nuevo m√©todo para extraer confianza por car√°cter:**
```python
def get_character_confidences(self, text: str) -> Dict[str, List[float]]:
    """
    Extrae la confianza individual de cada car√°cter en el texto detectado.
    
    Google Vision API retorna:
    - text_annotations[0]: Texto completo con confianza general
    - text_annotations[1:]: Palabras individuales con sus bounds y confidence
    
    Args:
        text: El texto (c√©dula) para el cual queremos las confianzas
        
    Returns:
        Dict con:
        - 'confidences': List[float] con confianza de cada car√°cter
        - 'positions': List[int] con posici√≥n de cada car√°cter
        - 'average': float con confianza promedio
        
    Example:
        >>> confidences = adapter.get_character_confidences("1036221525")
        >>> confidences
        {
            'confidences': [0.98, 0.95, 0.97, 0.94, ...],
            'positions': [0, 1, 2, 3, ...],
            'average': 0.956
        }
    """
    if not self.last_raw_response:
        raise ValueError("No hay respuesta disponible. Ejecuta extract_numbers() primero.")
    
    # IMPLEMENTACI√ìN:
    # 1. Buscar el texto en las anotaciones
    # 2. Para cada car√°cter, encontrar su confianza en text_annotations
    # 3. Google Vision da confidence por palabra, necesitas interpolar por car√°cter
    # 4. Si no hay datos espec√≠ficos, usar confidence general de la palabra
    
    # NOTA: Google Vision API no da confianza a nivel de car√°cter directamente,
    # solo a nivel de palabra/s√≠mbolo. Necesitas:
    # - Usar text_annotations para obtener palabras detectadas
    # - Mapear cada palabra a sus caracteres
    # - Asignar el confidence de la palabra a todos sus caracteres
    
    pass  # IMPLEMENTAR AQU√ç
```

**Documentaci√≥n Google Vision API:**
- La respuesta `text_annotations` contiene lista de `EntityAnnotation`
- Cada `EntityAnnotation` tiene:
  - `.description`: Texto detectado
  - `.confidence`: Confianza (0.0 - 1.0)
  - `.bounding_poly`: Posici√≥n del texto

---

### TAREA 2: Modificar Azure Vision Adapter

**Archivo:** `src/infrastructure/ocr/azure_vision_adapter.py`

**Objetivo:** Exponer la confianza individual de cada car√°cter/palabra detectada.

**Cambios necesarios:**

1. **Agregar propiedad para guardar respuesta cruda:**
```python
class AzureVisionAdapter(OCRPort):
    def __init__(self, config: ConfigPort):
        # ... c√≥digo existente ...
        self.last_raw_response = None  # NUEVO
```

2. **Guardar respuesta completa:**
```python
def extract_numbers(self, image: Image.Image) -> List[str]:
    # ... c√≥digo existente ...
    result = self._get_read_result(operation_location)
    self.last_raw_response = result  # GUARDAR RESPUESTA
    # ... resto del c√≥digo ...
```

3. **Agregar m√©todo para extraer confianza por car√°cter:**
```python
def get_character_confidences(self, text: str) -> Dict[str, List[float]]:
    """
    Extrae la confianza individual de cada car√°cter en el texto detectado.
    
    Azure Read API v4.0 retorna:
    - analyzeResult.readResults[].lines[]: L√≠neas de texto
    - Cada line tiene .words[] con confidence individual
    
    Args:
        text: El texto (c√©dula) para el cual queremos las confianzas
        
    Returns:
        Dict con:
        - 'confidences': List[float] con confianza de cada car√°cter
        - 'positions': List[int] con posici√≥n de cada car√°cter  
        - 'average': float con confianza promedio
        
    Example:
        >>> confidences = adapter.get_character_confidences("1036221525")
        >>> confidences
        {
            'confidences': [0.97, 0.94, 0.98, 0.95, ...],
            'positions': [0, 1, 2, 3, ...],
            'average': 0.962
        }
    """
    if not self.last_raw_response:
        raise ValueError("No hay respuesta disponible. Ejecuta extract_numbers() primero.")
    
    # IMPLEMENTACI√ìN:
    # 1. Parsear analyzeResult.readResults
    # 2. Para cada line.words, obtener el texto y confidence
    # 3. Buscar las palabras que forman la c√©dula buscada
    # 4. Azure da confidence por palabra, asignar a cada car√°cter de esa palabra
    
    pass  # IMPLEMENTAR AQU√ç
```

**Documentaci√≥n Azure Read API:**
- El resultado tiene estructura: `analyzeResult.readResults[page].lines[line].words[word]`
- Cada `word` tiene:
  - `.text`: Texto detectado
  - `.confidence`: Confianza (0.0 - 1.0)
  - `.boundingBox`: Posici√≥n

---

### TAREA 3: Crear Ensemble con Votaci√≥n por D√≠gito

**Archivo:** `src/infrastructure/ocr/digit_level_ensemble_ocr.py` (crear nuevo)

Ya te proporcion√© el c√≥digo base en el artefacto anterior. Necesitas:

1. **Copiar el c√≥digo del artefacto** que te mostr√©
2. **Adaptarlo** para usar los nuevos m√©todos `get_character_confidences()` 
3. **Implementar `_extract_digit_confidences()`** correctamente:

```python
def _extract_digit_confidences(
    self, 
    cedula: str, 
    ocr: OCRPort, 
    source: str
) -> List[DigitConfidence]:
    """
    Extrae la confianza individual de cada d√≠gito usando el nuevo m√©todo.
    """
    try:
        # Obtener confianzas del adapter
        conf_data = ocr.get_character_confidences(cedula)
        
        digits = []
        for i, (digit, conf) in enumerate(zip(cedula, conf_data['confidences'])):
            digits.append(DigitConfidence(
                digit=digit,
                confidence=conf,
                source=source,
                position=i
            ))
        
        return digits
        
    except Exception as e:
        self.logger.error(f"Error extrayendo confianzas de {source}: {e}")
        # Fallback: confianza uniforme
        return [
            DigitConfidence(digit=d, confidence=0.85, source=source, position=i)
            for i, d in enumerate(cedula)
        ]
```

---

### TAREA 4: Actualizar Factory Pattern

**Archivo:** `src/infrastructure/ocr/__init__.py`

Actualizar para incluir el nuevo ensemble:

```python
from .google_vision_adapter import GoogleVisionAdapter
from .azure_vision_adapter import AzureVisionAdapter
from .digit_level_ensemble_ocr import DigitLevelEnsembleOCR

def create_ocr_adapter(config):
    """Factory para crear el OCR adapter seg√∫n configuraci√≥n."""
    provider = config.get('ocr.provider', 'google_vision')
    
    if provider == 'google_vision':
        return GoogleVisionAdapter(config)
    
    elif provider == 'azure_vision':
        return AzureVisionAdapter(config)
    
    elif provider == 'digit_ensemble':
        # Crear ambos adapters
        google = GoogleVisionAdapter(config)
        azure = AzureVisionAdapter(config)
        
        # Retornar ensemble que los combina
        return DigitLevelEnsembleOCR(
            config=config,
            primary_ocr=google,
            secondary_ocr=azure
        )
    
    else:
        raise ValueError(f"OCR provider desconocido: {provider}")

__all__ = [
    'GoogleVisionAdapter',
    'AzureVisionAdapter', 
    'DigitLevelEnsembleOCR',
    'create_ocr_adapter'
]
```

---

### TAREA 5: Actualizar Configuraci√≥n

**Archivo:** `config/settings.yaml`

Agregar nueva configuraci√≥n:

```yaml
ocr:
  # Opciones: 'google_vision', 'azure_vision', 'digit_ensemble'
  provider: digit_ensemble
  
  # Configuraci√≥n del ensemble por d√≠gito
  ensemble:
    # Confianza m√≠nima que debe tener un d√≠gito individual para ser aceptado
    min_digit_confidence: 0.70
    
    # Ratio m√≠nimo de acuerdo entre ambos OCR (0.6 = 60% de d√≠gitos deben coincidir)
    # Si hay mucho desacuerdo, probablemente ninguno detect√≥ bien la c√©dula
    min_agreement_ratio: 0.60
    
    # Habilitar logging detallado de comparaciones
    verbose_logging: true
  
  # Configuraci√≥n de Google Vision (existente)
  google_vision:
    authentication: application_default
    project_id: firmas-automatizacion
    confidence_threshold: 0.85
    
  # Configuraci√≥n de Azure Vision (existente)
  azure_vision:
    endpoint: "${AZURE_VISION_ENDPOINT}"
    subscription_key: "${AZURE_VISION_KEY}"
    api_version: "2024-02-01"
    confidence_threshold: 0.85
    max_retries: 3
    timeout: 30

# El resto de la configuraci√≥n se mantiene igual
image_preprocessing:
  enabled: true
  upscale_factor: 3
  # ... etc
```

---

### TAREA 6: Tests Unitarios

**Archivo:** `tests/unit/test_digit_level_ensemble.py` (crear nuevo)

Implementar tests para validar:

```python
import pytest
from PIL import Image
from unittest.mock import Mock, MagicMock

class TestDigitLevelEnsemble:
    """Tests para el ensemble con confianza por d√≠gito."""
    
    def test_get_character_confidences_google(self):
        """Test que Google Vision retorna confianzas por car√°cter."""
        # Crear mock de GoogleVisionAdapter
        # Verificar que get_character_confidences() funciona
        pass
    
    def test_get_character_confidences_azure(self):
        """Test que Azure Vision retorna confianzas por car√°cter."""
        pass
    
    def test_digit_level_combination_same_result(self):
        """Test cuando ambos OCR coinciden 100%."""
        # Google: "1036221525" (todos 95% confianza)
        # Azure:  "1036221525" (todos 96% confianza)
        # Resultado esperado: "1036221525" con confianza ~95.5%
        pass
    
    def test_digit_level_combination_different_digit(self):
        """Test cuando difieren en un d√≠gito."""
        # Google: "1036221525" (d√≠gito 0: 98%)
        # Azure:  "7036221525" (d√≠gito 0: 85%)
        # Resultado esperado: "1036221525" (elige el de mayor confianza)
        pass
    
    def test_digit_level_combination_low_confidence_rejection(self):
        """Test que rechaza resultados con confianza muy baja."""
        # Google: "1036221525" (d√≠gito 5: 60%)
        # Azure:  "1036221525" (d√≠gito 5: 65%)
        # Ambos bajo el threshold de 70%
        # Resultado esperado: None (rechazado)
        pass
    
    def test_low_agreement_ratio_rejection(self):
        """Test que rechaza cuando hay poco acuerdo entre OCR."""
        # Google: "1036221525"
        # Azure:  "7894567890"
        # Solo coinciden en 2 d√≠gitos = 20% agreement
        # Resultado esperado: None (bajo agreement_ratio de 60%)
        pass
    
    def test_match_cedulas_by_similarity(self):
        """Test del emparejamiento de c√©dulas similares."""
        pass
    
    def test_fallback_to_best_individual(self):
        """Test del fallback cuando no hay coincidencias."""
        pass
```

---

## üìä M√âTRICAS DE √âXITO

La implementaci√≥n ser√° exitosa si:

1. ‚úÖ **Google Vision Adapter** expone `get_character_confidences()`
2. ‚úÖ **Azure Vision Adapter** expone `get_character_confidences()`
3. ‚úÖ **DigitLevelEnsembleOCR** combina correctamente por d√≠gito
4. ‚úÖ **Tests pasan** todos los casos de prueba
5. ‚úÖ **Logging claro** muestra decisiones de combinaci√≥n
6. ‚úÖ **Precisi√≥n mejora** a 98-99%+ en pruebas reales

### Comparaci√≥n Esperada

| M√©trica | Google Solo | Azure Solo | Ensemble D√≠gito |
|---------|------------|------------|-----------------|
| Precisi√≥n | 95-98% | 96-98% | **98-99.5%** ‚ú® |
| Errores 1 vs 7 | 1-3% | 1-2% | **< 0.5%** ‚ú® |
| Confianza avg | 95% | 96% | **97%** ‚ú® |
| Tiempo | 1-2 seg | 1-2 seg | 2-3 seg |
| Costo | $5 COP | $3 COP | $8 COP |

---

## üîç EJEMPLO DE OUTPUT ESPERADO

Cuando ejecutes el sistema con el nuevo ensemble, deber√≠as ver:

```
==================================================================
INICIANDO ENSEMBLE OCR CON CONFIANZA POR D√çGITO
==================================================================

‚úì OCR Primario (Google) encontr√≥: 3 c√©dulas
‚úì OCR Secundario (Azure) encontr√≥: 3 c√©dulas
‚úì Emparejadas: 3 c√©dulas

[1/3] Procesando c√©dula:
  Primary (Google):   1036221525 (conf: 94.2%)
  Secondary (Azure):  7036221525 (conf: 91.8%)
  
  Comparaci√≥n d√≠gito por d√≠gito:
  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚îÇ Pos ‚îÇ Google         ‚îÇ Azure          ‚îÇ Elegido  ‚îÇ
  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
  ‚îÇ  0  ‚îÇ '1' (98.2%)    ‚îÇ '7' (87.5%)    ‚îÇ '1' (G)  ‚îÇ
  ‚îÇ  1  ‚îÇ '0' (95.3%)    ‚îÇ '0' (96.1%)    ‚îÇ '0' (A)  ‚îÇ
  ‚îÇ  2  ‚îÇ '3' (92.7%)    ‚îÇ '3' (97.2%)    ‚îÇ '3' (A)  ‚îÇ
  ‚îÇ  3  ‚îÇ '6' (94.1%)    ‚îÇ '6' (95.4%)    ‚îÇ '6' (A)  ‚îÇ
  ‚îÇ  4  ‚îÇ '2' (89.3%)    ‚îÇ '2' (93.8%)    ‚îÇ '2' (A)  ‚îÇ
  ‚îÇ  5  ‚îÇ '2' (93.6%)    ‚îÇ '2' (91.2%)    ‚îÇ '2' (G)  ‚îÇ
  ‚îÇ  6  ‚îÇ '1' (96.4%)    ‚îÇ '7' (84.9%)    ‚îÇ '1' (G)  ‚îÇ
  ‚îÇ  7  ‚îÇ '5' (90.1%)    ‚îÇ '5' (93.3%)    ‚îÇ '5' (A)  ‚îÇ
  ‚îÇ  8  ‚îÇ '2' (88.7%)    ‚îÇ '2' (92.1%)    ‚îÇ '2' (A)  ‚îÇ
  ‚îÇ  9  ‚îÇ '5' (95.2%)    ‚îÇ '5' (94.8%)    ‚îÇ '5' (G)  ‚îÇ
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
  
  Estad√≠sticas:
  - Acuerdo: 80% (8/10 d√≠gitos coincidieron)
  - Confianza promedio: 96.4%
  - Fuentes: Google: 5 d√≠gitos, Azure: 5 d√≠gitos
  
  ‚Üí RESULTADO FINAL: 1036221525 ‚úÖ
    Confianza: 96.4% (mejor que ambos OCR individuales)

[2/3] Procesando c√©dula:
  Primary (Google):   3446532 (conf: 88.5%)
  Secondary (Azure):  3446532 (conf: 92.3%)
  
  ‚Üí RESULTADO FINAL: 3446532 ‚úÖ
    Confianza: 91.2%
    Acuerdo: 100% (id√©ntico en ambos OCR)

[3/3] Procesando c√©dula:
  Primary (Google):   43821028 (conf: 87.2%)
  Secondary (Azure):  48821028 (conf: 85.9%)
  
  ‚ö† Bajo acuerdo: 90% (9/10 d√≠gitos)
  Pos 1: '3' (73.2%) vs '8' (71.8%) ‚Üí Ambos bajo threshold
  
  ‚úó DESCARTADA (confianza insuficiente en posici√≥n cr√≠tica)

==================================================================
RESULTADO FINAL: 2 c√©dulas extra√≠das con alta confianza
==================================================================
```

---

## üéì DOCUMENTACI√ìN REQUERIDA

Despu√©s de implementar, crear/actualizar:

1. **`docs/DIGIT_ENSEMBLE.md`** (nuevo)
   - Explicaci√≥n detallada de c√≥mo funciona
   - Diagramas de flujo
   - Ejemplos de casos de uso
   - Comparaci√≥n con m√©todos tradicionales

2. **`docs/ACCURACY_TIPS.md`** (actualizar)
   - Agregar secci√≥n sobre ensemble por d√≠gito
   - Cu√°ndo usarlo vs OCR individual
   - Configuraci√≥n √≥ptima de thresholds

3. **`README.md`** (actualizar)
   - Agregar nueva opci√≥n de OCR: `digit_ensemble`
   - Actualizar m√©tricas de precisi√≥n

---

## üöÄ ORDEN DE IMPLEMENTACI√ìN SUGERIDO

1. ‚úÖ **Modificar GoogleVisionAdapter** ‚Üí agregar `get_character_confidences()`
2. ‚úÖ **Modificar AzureVisionAdapter** ‚Üí agregar `get_character_confidences()`
3. ‚úÖ **Crear DigitLevelEnsembleOCR** ‚Üí implementar l√≥gica de combinaci√≥n
4. ‚úÖ **Actualizar Factory** ‚Üí agregar opci√≥n `digit_ensemble`
5. ‚úÖ **Actualizar settings.yaml** ‚Üí nueva configuraci√≥n
6. ‚úÖ **Crear tests** ‚Üí validar comportamiento
7. ‚úÖ **Documentar** ‚Üí crear/actualizar docs
8. ‚úÖ **Probar con im√°genes reales** ‚Üí validar mejora de precisi√≥n

---

## ‚ö†Ô∏è CONSIDERACIONES IMPORTANTES

### Performance
- El ensemble ejecuta **ambos OCR en paralelo** ‚Üí tiempo ~1.5-2x individual
- Para 1000 im√°genes: ~30-40 minutos (vs 15-20 minutos con uno solo)
- **Vale la pena** si ganas 3-5% de precisi√≥n

### Costos
- **Duplica el costo** (usas ambas APIs)
- Google: $5.16 COP/1000 imgs
- Azure: $3.44 COP/1000 imgs
- **Total: ~$8.60 COP/1000 imgs**
- Para 5000 imgs/mes: ~$43,000 COP/mes
- **Sigue siendo muy econ√≥mico** para la mejora de precisi√≥n

### Cu√°ndo NO usar ensemble
- Im√°genes de muy alta calidad (escritura impresa)
- Presupuesto muy ajustado
- Velocidad es m√°s importante que precisi√≥n

### Cu√°ndo S√ç usar ensemble
- ‚úÖ **Escritura manuscrita dif√≠cil** (tu caso)
- ‚úÖ **Errores cr√≠ticos inaceptables** (c√©dulas incorrectas)
- ‚úÖ **Necesitas m√°xima confianza** (legal/electoral)
- ‚úÖ **Tienes presupuesto** (aunque sea m√≠nimo)

---

## üìû RESULTADO FINAL ESPERADO

Con esta implementaci√≥n, deber√≠as lograr:

1. üéØ **Precisi√≥n: 98-99.5%** (vs 95-98% actual)
2. üéØ **Errores cr√≠ticos: < 0.5%** (vs 1-3% actual)
3. üéØ **Confianza promedio: 97%** (vs 95% actual)
4. üéØ **Validaci√≥n cruzada autom√°tica** entre dos IA de diferentes proveedores
5. üéØ **Logging detallado** para auditor√≠a y debugging
6. üéØ **M√©tricas por d√≠gito** para an√°lisis de calidad

**Esto te dar√° la confianza necesaria para conseguir la inversi√≥n del proyecto.** üí∞

---

## ü§ñ FORMATO DE RESPUESTA ESPERADO

Claude Code, por favor genera:

1. ‚úÖ C√≥digo completo de `get_character_confidences()` para **GoogleVisionAdapter**
2. ‚úÖ C√≥digo completo de `get_character_confidences()` para **AzureVisionAdapter**  
3. ‚úÖ C√≥digo completo de `DigitLevelEnsembleOCR` (ya proporcionado, ajustar si necesario)
4. ‚úÖ Actualizaci√≥n de `__init__.py` con factory pattern
5. ‚úÖ Actualizaci√≥n de `settings.yaml` con nueva configuraci√≥n
6. ‚úÖ Tests unitarios completos en `test_digit_level_ensemble.py`
7. ‚úÖ Script de ejemplo de uso
8. ‚úÖ Documentaci√≥n en `docs/DIGIT_ENSEMBLE.md`

---

**¬øListo para implementar el ensemble m√°s inteligente y preciso posible?** üöÄüéØ

Este sistema te va a dar resultados de nivel empresarial/gubernamental que justificar√°n cualquier inversi√≥n en el proyecto.